---
title: kuangbin数论题单
description: 
date: 2021-02-08 16:15:00
categories:
 - 数论
tags:
 - 数论
mathjax: true
---
> 题单地址：[[kuangbin带你飞]专题1-23](https://vjudge.net/article/187)

<!--more-->

## LightOJ 1370 Bi-shoe and Phi-shoe
筛法得到欧拉函数的值


**代码**
```c++
#define LOCAL0
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
#define debug(msg) cout << (msg) << endl
#define FOR(i, a, b) for (int i=a; i<=(b); i++)
#define ROF(i, a, b) for (int i=a; i>=(b); i--)
#define pb(x) push_back(x) 
#define ALL(x) x.begin(), x.end()
#define RALL(x) x.rbegin(), x.rend()
#define sz(x) (int)x.size()
#define JUDGE(x) if(x) cout << "Yes\n"; else cout << "No\n";
using namespace std;
typedef long long ll;
const ll mod = 1e9+7;
int euler[2000005];
void getEuler(int n){
	euler[1] = 1;
	for(int i=2; i<=n; i++){
		if(!euler[i]){
			for(int j=i; j<=n; j += i){
				if(!euler[j]){
					euler[j] = j;
				}
				euler[j] = euler[j]/i*(i-1);
			}
		}
	}
}
int mp[2000005];
int main()
{
	#ifdef LOCAL
		freopen("in.txt", "r", stdin);
    	freopen("out.txt", "w", stdout);
	#endif
	getEuler(2000005);
	memset(mp, INF, sizeof(mp));
	FOR(i, 1, 2000005){
		if(euler[i]<=2000000){
			mp[euler[i]] = min(mp[euler[i]], i);
		}
	}
	ROF(i, 1500004, 1){
		mp[i] = min(mp[i], mp[i+1]);
	}
	mp[1] = 2;
	int T;
	cin >> T;
	FOR(tt, 1, T){
		ll ans = 0;
		int n;
		cin >> n;
		int t;
		FOR(i, 1, n){
			cin >>t;
			//cout << t << " " << mp[t] << endl;
			ans += mp[t];
		}
		printf("Case %d: %lld Xukha\n",tt,ans);
	}
	return 0;
}
```
---

## LightOJ 1341 Aladdin and the Flying Carpet
网上很多代码对$1-b$进行循环，复杂度是不正确的。由于$a$的素因数最多只有$\log_{2}a$个。设$a=p_1^{k_1}p_1^{k_2}...p_1^{k_n}$，由基本不等式$k_1k_2..k_n<=(\frac{k_1+k_2...+k_n}{n})^2<=(\frac{\log_{2}a}{n})^2$，可知a的所有素因数个数的乘积不会太大，所以可以用$dfs$枚举$a$所有可能的因数。

**代码**
```c++
#define LOCAL0
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
#define debug(msg) cout << (msg) << endl
#define FOR(i, a, b) for (int i=a; i<=(b); i++)
#define ROF(i, a, b) for (int i=a; i>=(b); i--)
#define pb(x) push_back(x) 
#define ALL(x) x.begin(), x.end()
#define RALL(x) x.rbegin(), x.rend()
#define sz(x) (int)x.size()
#define JUDGE(x) if(x) cout << "Yes\n"; else cout << "No\n";
using namespace std;
typedef long long ll;
const ll mod = 1e9+7;
const int MAXN=1000000;
// 素数筛选
int prime[MAXN+1];
void getPrime(){
	for(int i=2; i<=MAXN; i++){
		if(!prime[i]) prime[++prime[0]]=i;
		for(int j=1; j<=prime[0]&&prime[j]<=MAXN/i; j++){
			prime[prime[j]*i] = 1;
			if(i%prime[j]==0) break;
		}
	}
}
// 合数分解
ll factor[100][2];
int factCnt;
void getFactors(ll x){
	ll temp = x;
	factCnt = 0;
	for(int i=1; i<=prime[0] && prime[i]<=temp/prime[i]; i++){ //cout << i << " " << temp << endl;
		factor[factCnt][1] = 0;
		if(temp%prime[i]==0){
			factor[factCnt][0] = prime[i];
			while(temp%prime[i]==0){
				factor[factCnt][1]++;
				temp /= prime[i];
			}
			factCnt++;
		}
	}
	if(temp!=1){
		factor[factCnt][0] = temp;
		factor[factCnt++][1] = 1;
	}
}
ll a, b;
ll ans;
void dfs(ll now, ll tot){
	if(now==factCnt){
		if(tot*tot!=a && tot>=b && a/tot>=b) {
			ans++;
		}
		return;
	}
	ll temp = 1;
	FOR(i, 0, factor[now][1]){
		tot *= temp;
		dfs(now+1, tot);
		tot /= temp;
		temp *= factor[now][0];
	}
	return;
}
int main()
{
	#ifdef LOCAL
		freopen("in.txt", "r", stdin);
    	freopen("out.txt", "w", stdout);
	#endif
	getPrime();
	int T;
	cin >> T;
	FOR(tt, 1, T){
		ans = 0;
		cin >> a >> b;
		getFactors(a);
		dfs(0, 1);
		ans /= 2;
		printf("Case %d: %d\n", tt, ans);
	}
	return 0;
}
```
---

## LightOJ 1336 Sigma Function
将题目所给公式化简为$\sigma(n)=(1+p_1+..+p_1^{e_1})(1+p_2+..+p_2^{e_2})...(1+p_k+..+p_k^{e_k})$，如果要让$\sigma(n)$为奇数，由于当$p_k$为2时，$(1+p_k+..+p_k^{e_k})$一定为奇数，所以剩下的素因子的指数应该都是偶数，这样当2的指数也是偶数时，$n$是某个数的平方。当2的指数是奇数时，如果其余素因子的指数是偶数，应该有$n/2$是某个数的平方。综上$\sigma(n)$是奇数的条件就是$n$是某个数的平方或$n/2$是某个数的平方。这个题即输出$n-\sqrt{n}-\sqrt{n/2}$

**代码**
```c++
#define LOCAL0
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
#define debug(msg) cout << (msg) << endl
#define FOR(i, a, b) for (int i=a; i<=(b); i++)
#define ROF(i, a, b) for (int i=a; i>=(b); i--)
#define pb(x) push_back(x) 
#define ALL(x) x.begin(), x.end()
#define RALL(x) x.rbegin(), x.rend()
#define sz(x) (int)x.size()
#define JUDGE(x) if(x) cout << "Yes\n"; else cout << "No\n";
using namespace std;
typedef long long ll;
const ll mod = 1e9+7;
const int maxn=100000;
int main()
{
	#ifdef LOCAL
		freopen("in.txt", "r", stdin);
    	freopen("out.txt", "w", stdout);
	#endif
	int t;
	cin >> t;
	FOR(i, 1, t){
		ll n;
		cin >> n;
		n -= (ll)sqrt(n)+(ll)sqrt(n/2);
		cout << "Case " << i << ": " << n << endl;
	}
	return 0;
}
```
---
## LightOJ 1282 Leading and Trailing
后三位用快速幂对$n^k$模1000就可以了。计算前三位时把原数变形为$n^k=10^{\log_{10}a^k}=10^{k\log_{10}a}$，用$x，y$表示$k\log_{10}a$的整数部分与小数部分，可得$n^k=10^{x+y}=10^x*10^y$，则$n^k$的位数是由$10^x$决定的，各位数字是由$10^y$决定的，而$0\leq y<1$，所以$1\leq 10^y<10$，$10^y *100$的整数部分就是$n^k$的前三位。
**代码**
```c++
#define LOCAL0
#include <bits/stdc++.h>
#define INF 0x3f3f3f3f
#define debug(msg) cout << (msg) << endl
#define FOR(i, a, b) for (int i=a; i<=(b); i++)
#define ROF(i, a, b) for (int i=a; i>=(b); i--)
#define pb(x) push_back(x) 
#define ALL(x) x.begin(), x.end()
#define RALL(x) x.rbegin(), x.rend()
#define sz(x) (int)x.size()
#define JUDGE(x) if(x) cout << "Yes\n"; else cout << "No\n";
using namespace std;
typedef long long ll;
const ll mod = 1e9+7;
const int maxn=100000;
//pow(x,n)%mod O(logn)
ll mod_pow(ll x,ll n,ll mod)
{
    ll res=1;
    while(n>0){
        if(n&1) res=res*x%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
int main()
{
	#ifdef LOCAL
		freopen("in.txt", "r", stdin);
    	freopen("out.txt", "w", stdout);
	#endif
	int T;
	cin >> T;
	FOR(tt, 1, T){
		ll n, k;
		cin >> n >> k;
		ll ans2 = mod_pow(n, k, 1000);
		double ans1 = k*log10(n);
		ans1 = fmod(ans1, 1);
		cout << "Case " << tt << ": " << (int)(pow(10, ans1)*100) << " ";
		cout << setw(3) << setfill('0') << ans2 << endl;
	}
	return 0;
}
```